# 数据管理平台V2
## 一、将原先O端的代码(使用vue2.x + js)的代码移植到数据管理平台，并使用vue3 + ts + pinia 重构

## 二、点击app_id通过设定cookie值从ops.xiaoe-tools.com跳转到yarn126.xiaoe-tools.com页面并绕过登录
点击app_id 跳转到yarn126.xiaoe-tools.com页面，并且使用admin账号直接登录，由于公司内部人员都是使用admin账号登录，而且密码没有规律，很容易遗忘，因此决定直接绕过登录。

整体方案是(思路来源于同域名下的单点登录)：
* 1、进入页面，主动向后端发送请求获取cookie，然后通过 document.cookie = 'key:value; domain=.xiaoe-tools.com'
* 2、用户点击app_id，使用window.open方法打开指定路径的页面。
使用上述方法跳转并绕过登录态有几个前提：
1、在yarn126.xiaoe-tools.com页面，所有用户都是使用同一个账号密码登录，这样才能通过注入cookie的方法绕过登录。
2、我们在设置Cookie时，只能设置顶域和自己的域，不能设置其他的域。因此跳转的页面和本页面必须在同一顶域下，document.cookie的方法是BOM方法，它只能设定本域名下或者上级域名的cookie(即使它指定了domain)。当浏览器发生跳转时默认会自动携带对应域名下的所有cookie，所以如果是不同域，则跳转后不会带上刚才设定的cookie。
具体代码如下：
```vue
<script setup>
onMounted(async () => {
  // 获取cookie值
    const { data } = await getCookie();
    if (data?.data) {
      // 往对应域名上设置cookie
        Object.keys(data.data).forEach((key) => {
            document.cookie = `${key}=${data.data[key]}; domain=.xiaoe-tools.com`;
        });
    }
});
// 点击跳转
function goToYarn(data) {
    window.open(`https://yarn126.xiaoe-tools.com:30002/gateway/emr/yarn/proxy/${data.appId}/#/overview`);
}
</script>
```
三、使用vue-codemirror展示代码
vue-codemirror是一个代码展示第三方库，核心是使用了codemirror6.x。我们可以通过设定编辑器的主题、语言包和一些其他的扩展来拓展vue-codemirror的能力

四、使用Unocss的原理书写样式
UnoCSS 是一个即时原子化 CSS 引擎，或者说是一个函数式css引擎。通过预设模拟大多数已有原子化 CSS 框架的功能。
实现原理： 核心就是预置一大堆 class 样式，尽量将这些 class 样式简单化、单一化，在开发过程中，可以直接在 DOM 中写预置好的 class 名快速实现样式，而不需要每次写简单枯燥大量的 css 样式

优势：
1、按需加载，通过预扫描 --> 生成的方式实现按需加载

2、速度非常快，比Tailwind和windi快上好几百倍，原因在于Tailwind依赖于Postcss解析后的AST进行修改，Windi则是编写了一个自定义解析器和AST。而unocSS通过非常高效的字符串拼接来直接生成对应的CSS而非引入整个编译过程。同时，UnocSS对类名和生成的CSS字1符串进行了缓存，当再次遇到相同的实用工具类时，它可以绕过整个匹配和生成的过程。

3、易用，所有功能都可以通过预设和内联配置提供

和Tailwind的对比：
Tailwind:
* 工作过程：生成所有规则 ==> 扫描你代码中用到的规则 ==> 抛弃你代码中没有使用的规则
* Tailwind会依赖postcss生成的AST树

unocss:
* 工作过程：扫描你代码中用到的规则==>按需匹配并生成规则
* unocSs并不依赖AST，而是通过非常的字符串拼接来直接生成对应的cSS而不引入整个编译过程

# 服务数字化

## 一、通通知道回答的过程
用户发送问题 --> 将问题发送给后端验证有无违规词，后端是通过第三方验证 --> 验证通过后像后端发送请求，传给后端问题类型及问题内容  --> 后端调用chatGPT和文心一言，然后返回答案 --> 前端拿到答案后，调用循环，将答案一个字一个字的显示，让用户感觉像是人在回答。

## 二、在线客服

### 推荐问题
通过调用基础的接口，获取到用户目前所处板块(直播、课程、店铺、圈子等) --> 像后端获取该目录下5个常见问题，常见问题从各板块业务负责人处收集， 如果无法获取到目前所处板块或者用户当前处于首页，则随机返回5个常见问题 --> 点击某个问题，直接发送问题


# 社群机器人
## 项目背景
提供一个机器人群聊管理台给运营部门，他们可以通过将机器人拉进某个群聊，然后设置定时推送的消息，到了设定的时间，机器人就能自动推送消息。

1、设置定时推送的时间、内容、是否重复、什么时候终止
2、使用fullCalendar实现推送事件在日历上展示，类似于企业微信的日程
3、使用tippy实现点击日历上的事件，展示详情，并且提供编辑和删除的入口

# AI接入企业微信群
## 项目背景
用户可以购买AI员工(rpa机器人，由阿里提供)，然后使用自己企微扫码登录(实际上是登录到我们公司的一台云电脑)，可以绑定AI助理，AI助理其实是一个机器，它可以自动回复用户消息，回复的消息来源于两处：用户自己建立的知识库以及GPT4。把AI助理拉到某个群中，就可以实现每日推送，以及@回复等操作(需要能够绑定的企微的会话存档权限，即能够识别上下文)。

1、通过自定义element plus命名空间防止避免命名冲突，和样式冲突

2、通过vite插件自动按需导入element plus组件

3、自动按需导入element plus图标

4、解决自定义命名空间后，MessageBox以及Message默认样式不生效的问题

5、使用`vite-plugin-style-import`自动导入svg图片

## 难题
在做项目的过程中，发现使用element plus的有些组件，比如Message、MessageBox组件，样式会出问题。即无法定位到正确位置，并且排布，字体、颜色都和官方文档的示例不同，纯粹的是一个BFC。而且一时难以定位到问题的来源，因为大部分组件都是可以正常使用的。
但是当时由于项目是比较急的，所以采取了一个应急手段去处理这个问题。就是使用我们公司的一个内部ui组件库，这个组件库也是基于element plus开发的，我们公司有个专门的部门去维护，但是为什么一开始不使用这套ui组件库呢，是因为，他们其实是支持vue2的，对于vue3只有部分组件支持，考虑到一个项目最好使用一套ui库，所以刚开始的时候是选择了element plus的。
总之，当时是采用了这样一个应急方案解决了这个消息弹窗的样式问题，然后项目也是可以正常上线和使用的。但是为什么element plus的某些组件会出现样式问题以及为什么我们公司这套基于element plus开发的ui库又可以正常使用，其实当时是没有找到原因的。后面项目上线并且可以正常使用了，就抽空回头来排查这个问题。也排查了很久，发现是因为我们当时为了避免样式冲突使用了自定义命名空间导致说一些组件的样式失效了。但是当时在stackoverflow，devv，chatgpt等等包括element plus官方文档，都没有给到一个正确的解决方案。最后是在element plus的issue中找到了答案，使用按需自动导入element plus组件的时候，element内部会扫描你的`template`标签的内容来确定要引入哪些组件和样式，比如，他发现你的模板中有使用`el-button`这个标签，他就会自动导入button组件及对应的样式。但是对于，Message、MessageBox等等这些不会在模板中使用，而是通过js直接调用的组件，element plus是无法检测到是否有使用的，这个时候就需要我们自己去手动导入组件和样式了。
但是后面又发现了问题，就是每次使用Message、MessageBox，包括在js中以服务的方式调用loading的情况，我都需要在`node_modules`文件中找到对应组件的样式，然后再次引入。这样比较麻烦而且容易出错，后面又在网上搜索有没有对应的解决方案，发现不仅组件可以按需自动导入，样式也可以同一个`vite-plugin-style-import`的自动按需导入。

# AI助理接入微信生态圈
## 描述
将AI助理接入到微信客服、公众号、视频号、小程序等环境，目的是为了帮助商家在微信生态中使用AI助理自动回复消息
## 过程
用户询问 --> 微信捕获 --> 微信将信息返回给我们服务(需要在企微后台把小鹅通配置为第三方应用，并允许获取相应权限) --> 走AI助理逻辑
## 实现
这个项目之前是由电商的同学负责迭代的，由于公司高层决定将AI助理接入到微信生态，因此将之前原本属于电商负责的客服服务功能交由我们迭代。客服功能其实是好几个组件共同构成的。那么我们为了以后迭代不用去找他们借系统，决定在gitlab中新建一个系统来维护，并且使用monorepo架构，因为monorepo可以解决多个项目引用公共组件不好复用的问题。所以由我从零搭建一个monorepo架构的项目。这其实对我来说是比较困难的已经事情。
因为当时我只是听说过monorepo，并不知道如何使用以及monorepo能够帮我们解决什么问题。所以当时我接到项目的第一时间并没有急于开始，而是先花了一个上午的时间弄清楚几个问题：什么是monorepo？monorepo能解决什么问题？如何使用monorepo？后面发现这东西还挺简单的，无非是在`pnpm-workspace.yaml`文件中声明几个工作区域，然后就能解决多个项目引用公共组件而无法复用的问题，而且它不像npm包，npm包引入的方式虽然也可以解决复用问题，但是如果公共组件迭代后，那么每个引用公共组件的项目都需要重新安装依赖，维护比较麻烦。而monorepo架构中，公共组件修改后，引用的项目是无须修改的，应该它在`package.json`文件中显示的是`workspace:*`，最终在编译的时候会被替换成最新的版本。

# sse流式接受ai回答

## 背景
刚开始的时候，我们采用的是普通的http请求接受ai的回答。整体流程大概是这样的，首先用户输入问题，然后前端发送一个校验的请求，看问题中是否含有敏感词，如果没有的话，前端再发送第二个http请求，并且利用时间戳和一个随机生成8位字符的函数拼接成msgID以及chatID(如果不是新建会话)，传入后端，这一步是为了方便入数据库和日志查询以及chatID和msgID的绑定，后端会返回一个chatID(如果是新建会话)。最后再发送第三个http请求，也就是将问题和生成的chatID、msgID传给后端，后端回调大模型的api，可能是chatGPT或者文心一言等等，后端会等大模型的回答完全返回后再将结果返回给前端展示。

整个链路是比较长且很耗时的。其实chatGPT他是就是以sse流式返回的，所以后面我们也决定采用sse的方式返回给前端，这样用户等待的时间也比较的短，更能有效留住客户。

## 难题
在完成开发后，我们遇到一个问题，因为我们为了方便写入数据库以及后期查看日志，是一个message对应一个msgID，且不允许重复的。但是有的时候，后端总是会报msgID重复也没有返回数据。但是查看控制台只有一个请求，而且我们通过前端埋点上报后，查看日志，发现确实有两条连续的记录，其中一条是200，另外一条是401，而且两条记录的间隔时间很短，是毫秒级别的。然后我监听sse的三个回调函数，onmessage,onerror,onopen发现，在有问题的情况下他没有进入onopen而是直接进入的onerror，这就说明浏览器没有和服务器建立sse链接。但矛盾的是日志中确实有一条200的记录。

经过多次的验证发现，我们在网络较好的情况下，不会出现这种现象，加上sse的重发机制。我们就猜想是浏览器第一次向后端发起sse请求，然后服务器会返回一个readyState状态码为1给客户端，告诉客户端已链接成功，但是由于网络的原因，导致客户端未能及时收到状态的改变，所以浏览器又发了一条请求，这个时候就会导致服务端检测到msgID已重复，然后返回401。

后面我的解决方案是后端做个兜底方案，就是请求成功后，将结果与参数同时写入到radis数据库，如果在短时间内sse有重发的情况，就直接返回radis数据库中的答案即可。

# vue3中挂载vue2组件

## 背景
新系统是vue3的，里面有一个用户导入的模块，复用B端管理台原有的组件，原有组件时vue2开发的，并且使用webpack以umd格式导出。

## 实现
在vue3系统中，我们用 npm alias 来安装 vue2，
```shell
pnpm add vue2@npm:vue@^2.7
```
在代码中这样实现

```js
import Vue from 'vue2'

function init() {
  // 在引入组件之前，先要在window上挂载Vue变量
  window.Vue = Vue
  createScript()
}

function createScript() {
  const el = document.createElement('script')
  el.src = 'xxxxx'   //组件cdn路径
  el.onload = mount  //脚本请求回来后在挂载
}

const Construct = Vue.extend(ComponentName)  //组件名有umd导出
const instance = new Construct({
  // 传入props
  propsData: {
    aaa: 111
  }
})
//传入事件
evens.forEach((eventName) => {
  instance.$on(eventName, events[eventName])
})

// 挂载
instance.$mount('#id')
```

## 难题
原先的组件内部有通过`$router.push`的方式跳转，但是在vue3中使用的`vue-router4.x`版本已经抛弃了这种方式，所以会导致阻塞并且抛出异常。后面我们是通过给挂载在window上的Vue这个变量自定义`$router.push`方法，然后使用`vue-router4.x`版本相应的方法去跳转，甚至可以使用location的方式。
```js
window.Vue.$router = {
  push() {
    //逻辑
  }
}
```

# AI行业标签
有一个管理台行业标签的业务，业务场景是这样的，用户点击主营行业的按钮，然后弹出一个弹窗供用户选择他的主营行业，其中按钮是我负责的，而弹窗是由基础业务中心负责的。整个场景都是比较简单的，对于基础中心的开发而言，他们需要提供一个组件给我，并且暴露相关的api，于我而言，就更简单了，只需监听用户点击事件，然后调用api即可。

开发过程中遇到的一个困惑的点是，当我接入基础提供的组件时，控制台抛出一个异常，具体问题是访问了某个不存在的变量中的属性或方法，也就是说有个变量未定义。那么发现这个问题的首先第一步，肯定就是找到弹窗的开发人员，让他确认下，代码是否有问题。后面发现他的代码并没有问题，因为在其他的一个地方也有使用他们的组件，而且是可以正常工作的。
那其实当时我还是挺疑惑的，因为我就是简单的一个按钮，然后点击调用api。后面通过打断点，然后在控制台通过调用栈去追踪到底是哪个地方调用了未声明的变量。后面发现问题的抛出在是vue内部，并且那个方法是vue实例上的，也就是说vue没有被定义。

然后又是和同事一起排查，什么原因导致的，最终我们发现是window上面没有挂载vue的原因。就是我们公司各个中心负责的模块不一样，然后各个模块可能又嵌套了其他中心的业务，所有各个中心很多时候都会提供组件给其他中心的同事使用，确保业务是在自己中心的。然后我们提供的方式通常有两种，一种是npm包，另外一种的就是微组件。通常我们优先都是选择提供微组件的，这样后期维护的话就不需要到引入的那个地方去改版本号。我们这次用的就是微组件。而我们的微组件是打包成一个umd的格式，然后我们公司之前同事开发了一个微组件的接入器，我看过他们的源码，本质就是通过系统名、微组件名和版本号，获取到cdn地址，然后创建script标签，并且把cdn地址赋值给script标签的src
那么开发弹窗组件的同事减小包的体积，在打包的时候通过配置vite.config.js中的`build.rollupOptions.external`属性把vue当作外部依赖没有打进构建包，并且配置了`build.rollupOptions.output.globals`，从全局中获取Vue的变量。本身这样配置是没有关系的，但是其实我们数据中心的系统为了兼容vue2和vue3两种微组件，所以我们在全局挂载的变量名vue指代的是vue2版本，而变量名vue3指代的是vue3版本。本次的微组件是通过vue3开发的，而在引入的时候却找的是vue2的实例，所以导致了报错，解决方案就是将`build.rollupOptions.output.globals`中vue的值指定为vue3。

# 广告投放

## 背景
我们会有一个信息采集的组件，主要是采集用户输入手机号，验证码，身份证件等等信息，这个组件由基础部门提供。然后我们有一个提交的按钮，点击提交按钮，就会做两个事情：首先保存采集到的用户的信息，然后弹出支付框付款。而且必须要用户先填写信息，然后才能付款，付款后才能加客服微信。因为我们需要用户信息，比如手机号，然后生成线索，在其他落地页付款，也是弹出同一个客服二维码，方便客户统计客服的业绩。
## 问题
某些情况下，用户在不填写信息的情况下点击按钮也可以直接付款，然后添加客服微信，这样可能每次弹出的二维码都不一样。

## 原因
因为落地页中的信息采集组件其实是可以配置的，客户可以根据需要配置他需要采集用户的哪些信息，必须要手机号，其他都是可选的，比如有的需要身份证，有的需要姓名，或者性别，有的可能还需要年龄，这都是为后面分析做准备的。由于信息采集的组件是由其他部门提供，所以我们需要传递一个落地页的id给组件，然后组件再去请求这个id要不要展示信息采集，以及需要展示收集哪些信息，但这个时候按钮可能已经渲染，并且用户点击了按钮。点击按钮就会触发信息采集的保存接口，但是如果这个时候信息采集内部的接口没有返回数据，则认为不需要进行信息采集(默认值决定)，就会直接通过，然后就会出现这个问题。

## 解决方案
最直接简单粗暴的方式时，在信息采集未加载之前，禁止按钮点击。但是按钮又是由另一个组件提供，这样做有两个弊端：
1、如果我们这样做的话，就需要把逻辑加入到组件内部，其实就增加了组件和业务的耦合性。
2、第一点还不是致命的，毕竟我们可以增加一个props解决。致命的是，这个组件不止渲染了一个按钮，还渲染了其他的组件，就是我们把要渲染的组件通过一个配置传给这个组件，让他内部循环帮我们渲染出我们想要的配置，如果把刚刚的逻辑加进去的话，必然会降低代码的灵活性。
最终我们想出了两个方案：

方案一： 借鉴vue响应式原理中的调度函数。当用户点击按钮的时候，我们先用一个集合将提交的逻辑放到一个函数中，并且把这个函数放到这个集合中，然后当信息采集组件加载成功后，再从这个桶里面拿出调度函数执行。其实在网络良好的情况下，这个两个时间间隔是比较短的，所以用户是看不出异常的。当然还有考虑，用户点击按钮的时候，信息采集已经加载好了，这个时候就直接执行函数就行了，不用放到集合中。

方案二：就是我们设置一个变量，初始情况可以是null，也可以是一个pendding状态的promise。然后在信息采集组件加载完成后，将promise的状态改为fullfilled。当用户点击按钮的时候，我们在promise.then中执行我们的保存信息采集的逻辑。如果用户是在信息采集组件加载完之前点击按钮，是不会执行promise.then当中的逻辑的，当组件加载完成后，由于promise的状态变更了，会从微任务队列中拿出提交逻辑执行。

最终我们觉得第二种方案更为优雅，所以采用了方案二。

