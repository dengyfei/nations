# 数据管理平台V2
## 一、将原先O端的代码(使用vue2.x + js)的代码移植到数据管理平台，并使用vue3 + ts + pinia 重构

## 二、点击app_id通过设定cookie值从ops.xiaoe-tools.com跳转到yarn126.xiaoe-tools.com页面并绕过登录
点击app_id 跳转到yarn126.xiaoe-tools.com页面，并且使用admin账号直接登录，由于公司内部人员都是使用admin账号登录，而且密码没有规律，很容易遗忘，因此决定直接绕过登录。

整体方案是(思路来源于同域名下的单点登录)：
* 1、进入页面，主动向后端发送请求获取cookie，然后通过 document.cookie = 'key:value; domain=.xiaoe-tools.com'
* 2、用户点击app_id，使用window.open方法打开指定路径的页面。
使用上述方法跳转并绕过登录态有几个前提：
1、在yarn126.xiaoe-tools.com页面，所有用户都是使用同一个账号密码登录，这样才能通过注入cookie的方法绕过登录。
2、我们在设置Cookie时，只能设置顶域和自己的域，不能设置其他的域。因此跳转的页面和本页面必须在同一顶域下，document.cookie的方法是BOM方法，它只能设定本域名下或者上级域名的cookie(即使它指定了domain)。当浏览器发生跳转时默认会自动携带对应域名下的所有cookie，所以如果是不同域，则跳转后不会带上刚才设定的cookie。
具体代码如下：
```vue
<script setup>
onMounted(async () => {
  // 获取cookie值
    const { data } = await getCookie();
    if (data?.data) {
      // 往对应域名上设置cookie
        Object.keys(data.data).forEach((key) => {
            document.cookie = `${key}=${data.data[key]}; domain=.xiaoe-tools.com`;
        });
    }
});
// 点击跳转
function goToYarn(data) {
    window.open(`https://yarn126.xiaoe-tools.com:30002/gateway/emr/yarn/proxy/${data.appId}/#/overview`);
}
</script>
```
三、使用vue-codemirror展示代码
vue-codemirror是一个代码展示第三方库，核心是使用了codemirror6.x。我们可以通过设定编辑器的主题、语言包和一些其他的扩展来拓展vue-codemirror的能力

四、使用Unocss的原理书写样式
UnoCSS 是一个即时原子化 CSS 引擎，或者说是一个函数式css引擎。通过预设模拟大多数已有原子化 CSS 框架的功能。
实现原理： 核心就是预置一大堆 class 样式，尽量将这些 class 样式简单化、单一化，在开发过程中，可以直接在 DOM 中写预置好的 class 名快速实现样式，而不需要每次写简单枯燥大量的 css 样式

优势：
1、按需加载，通过预扫描 --> 生成的方式实现按需加载

2、速度非常快，比Tailwind和windi快上好几百倍，原因在于Tailwind依赖于Postcss解析后的AST进行修改，Windi则是编写了一个自定义解析器和AST。而unocSS通过非常高效的字符串拼接来直接生成对应的CSS而非引入整个编译过程。同时，UnocSS对类名和生成的CSS字1符串进行了缓存，当再次遇到相同的实用工具类时，它可以绕过整个匹配和生成的过程。

3、易用，所有功能都可以通过预设和内联配置提供

和Tailwind的对比：
Tailwind:
* 工作过程：生成所有规则 ==> 扫描你代码中用到的规则 ==> 抛弃你代码中没有使用的规则
* Tailwind会依赖postcss生成的AST树

unocss:
* 工作过程：扫描你代码中用到的规则==>按需匹配并生成规则
* unocSs并不依赖AST，而是通过非常的字符串拼接来直接生成对应的cSS而不引入整个编译过程

# 服务数字化

## 一、通通知道回答的过程
用户发送问题 --> 将问题发送给后端验证有无违规词，后端是通过第三方验证 --> 验证通过后像后端发送请求，传给后端问题类型及问题内容  --> 后端调用chatGPT和文心一言，然后返回答案 --> 前端拿到答案后，调用循环，将答案一个字一个字的显示，让用户感觉像是人在回答。

## 二、在线客服

### 推荐问题
通过调用基础的接口，获取到用户目前所处板块(直播、课程、店铺、圈子等) --> 像后端获取该目录下5个常见问题，常见问题从各板块业务负责人处收集， 如果无法获取到目前所处板块或者用户当前处于首页，则随机返回5个常见问题 --> 点击某个问题，直接发送问题


# 社群机器人
## 项目背景
提供一个机器人群聊管理台给运营部门，他们可以通过将机器人拉进某个群聊，然后设置定时推送的消息，到了设定的时间，机器人就能自动推送消息。

1、设置定时推送的时间、内容、是否重复、什么时候终止
2、使用fullCalendar实现推送事件在日历上展示，类似于企业微信的日程
3、使用tippy实现点击日历上的事件，展示详情，并且提供编辑和删除的入口

# AI接入企业微信群
## 项目背景
用户可以购买AI员工(rpa机器人，由阿里提供)，然后使用自己企微扫码登录(实际上是登录到我们公司的一台云电脑)，可以绑定AI助理，把AI助理拉到某个群中，就可以实现每日推送，以及@回复等操作(需要能够绑定的企微的会话存档权限，即能够识别上下文)。

1、通过自定义element plus命名空间防止避免命名冲突，和样式冲突

2、通过vite插件自动按需导入element plus组件

3、自动按需导入element plus图标

4、解决自定义命名空间后，MessageBox以及Message默认样式不生效的问题

5、使用`vite-plugin-style-import`自动导入svg图片

## 难题
在做项目的过程中，发现使用element plus的有些组件，比如Message、MessageBox组件，样式会出问题。即无法定位到正确位置，并且排布，字体、颜色都和官方文档的示例不同，纯粹的是一个BFC。而且一时难以定位到问题的来源，因为大部分组件都是可以正常使用的。
但是当时由于项目是比较急的，所以采取了一个应急手段去处理这个问题。就是使用我们公司的一个内部ui组件库，这个组件库也是基于element plus开发的，我们公司有个专门的部门去维护，但是为什么一开始不使用这套ui组件库呢，是因为，他们其实是支持vue2的，对于vue3只有部分组件支持，考虑到一个项目最好使用一套ui库，所以刚开始的时候是选择了element plus的。
总之，当时是采用了这样一个应急方案解决了这个消息弹窗的样式问题，然后项目也是可以正常上线和使用的。但是为什么element plus的某些组件会出现样式问题以及为什么我们公司这套基于element plus开发的ui库又可以正常使用，其实当时是没有找到原因的。后面项目上线并且可以正常使用了，就抽空回头来排查这个问题。也排查了很久，发现是因为我们当时为了避免样式冲突使用了自定义命名空间导致说一些组件的样式失效了。但是当时在stackoverflow，devv，chatgpt等等包括element plus官方文档，都没有给到一个正确的解决方案。最后是在element plus的issue中找到了答案，使用按需自动导入element plus组件的时候，element内部会扫描你的`template`标签的内容来确定要引入哪些组件和样式，比如，他发现你的模板中有使用`el-button`这个标签，他就会自动导入button组件及对应的样式。但是对于，Message、MessageBox等等这些不会在模板中使用，而是通过js直接调用的组件，element plus是无法检测到是否有使用的，这个时候就需要我们自己去手动导入组件和样式了。
但是后面又发现了问题，就是每次使用Message、MessageBox，包括在js中以服务的方式调用loading的情况，我都需要在`node_modules`文件中找到对应组件的样式，然后再次引入。这样比较麻烦而且容易出错，后面又在网上搜索有没有对应的解决方案，发现不仅组件可以按需自动导入，样式也可以同一个`vite-plugin-style-import`的自动按需导入。

